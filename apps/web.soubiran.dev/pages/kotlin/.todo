bootstrap l'ide et projet vierge en kotlin
(faire un projet de contact manager)

qu'est ce que rest ? il faut avoir une petite phrase

l'enjeu, c'est de passer Ã  l'Ã©chelle mais tout seul (mdrr facile Ã  dire)
(lÃ , dans le processus de crÃ©ation, c'est chaotique mais super formateur et c'est se demander oÃ¹ est sa valeur)

first, google to know what to ask to ai, then ai to have a deeper explanantion


video youtube pour avoir la syntax de base et apprendre Ã  lire du kotlin

pour apprendre le testing, j'ai demandÃ© Ã  un agent de me faire un projet complet, l'idÃ©e est simple, ne pas partir d'une feuille blanche et avoir du contenu Ã  creuser parce que sur internet c'est vide
demander Ã  copilot des features Ã  ajouter et demander graduellement, au fur et Ã  mesure

la todo app, Ä‡a fonctionne super bien
j'ai ma rÃ©fÃ©rence (j'ai toujours eu besoin d'une rÃ©fÃ©rence, je me souviens en mathÃ©matique, c'Ã©tiat dÃ©jÃ  le cas, impossible de dÃ©marer un exo sans une rÃ©fÃ©rence)

ensuite, demander des idÃ©es de projets, shopping list avec save et restore dans un json (i/o, comment on gÃ¨re)
et ensuite, demander une review Ã  un agent kotlin expert lÃ  dedans

demande Ã  mon rÃ©seau parce que "Learning with AI, il n'y aucun contenu sur internet"

mettre le contenu du fichier TESTING_GUIDE dans web.soubiran.dev
faire un agent spÃ©cialiste ? faire un agent organizer ? faire un agent ochestrateur ? faire une web ui ?
faire un explainer ?

-> moyen de s'amuser mais il faut vÃ©ritablement apporter de la valeur

potentiellement, tout Ä‡a, fait un talk en meetup

il faut clarifier les frontiÃ¨res
domain -> entity
http -> dto -> controller -> dto -> service -> entity -> repository

---


Explaination (brief):
- Write unit tests for `ShoppingListServiceImpl` with a mocked `StorageService`.
- Use MockK and JUnit 5. Mock `loadShoppingList()` responses and verify `saveShoppingList()` is called with expected lists.
- Assert the service internal `getShoppingList()` reflects adds/removals.
- Place tests in `src/test/kotlin/service/impl/ShoppingListServiceImplTest.kt`.

Test file:
```kotlin
// src/test/kotlin/service/impl/ShoppingListServiceImplTest.kt
import io.mockk.every
import io.mockk.mockk
import io.mockk.verify
import io.takima.domain.ShoppingItem
import io.takima.service.StorageService
import io.takima.service.impl.ShoppingListServiceImpl
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.Test

class ShoppingListServiceImplTest {
    private val storage = mockk<StorageService>(relaxed = true)
    private val service = ShoppingListServiceImpl(storage)

    private fun item(id: String = "id", name: String = "name") =
        ShoppingItem(id = id, name = name)

    @Test
    fun `getShoppingList initially empty`() {
        assertTrue(service.getShoppingList().isEmpty())
    }

    @Test
    fun `addShoppingItem adds to in-memory list and saves combined storage list`() {
        val existing = listOf(item("a", "apple"))
        every { storage.loadShoppingList() } returns existing

        val toAdd = item("b", "banana")
        service.addShoppingItem(toAdd)

        // in-memory list updated
        val mem = service.getShoppingList()
        assertEquals(1, mem.size)
        assertTrue(mem.contains(toAdd))

        // verify load was called and save called with combined list
        verify(exactly = 1) { storage.loadShoppingList() }
        verify(exactly = 1) { storage.saveShoppingList(existing + toAdd) }
    }

    @Test
    fun `removeShoppingItem removes from in-memory list and updates storage`() {
        // prepare storage to return a list containing the item
        val stored = mutableListOf(item("x", "x-item"), item("y", "y-item"))
        every { storage.loadShoppingList() } returns stored.toList()

        val toRemove = item("r", "remove-me")
        // add to internal list using service API (this will call load and save once)
        service.addShoppingItem(toRemove)
        assertTrue(service.getShoppingList().contains(toRemove))

        // now adjust mocked load to reflect stored list prior to removal
        every { storage.loadShoppingList() } returns (stored + toRemove).toList()

        service.removeShoppingItem(toRemove)

        // in-memory list no longer contains the removed item
        assertFalse(service.getShoppingList().contains(toRemove))

        // verify save called with the storage list without the removed item
        verify { storage.saveShoppingList((stored + toRemove).filter { it != toRemove }) }
    }
}
```

Notes:
- Add Gradle dependencies if missing: `testImplementation "io.mockk:mockk:1.13.5"` and `testImplementation "org.junit.jupiter:junit-jupiter:5.9.3"`.
- Use real `ShoppingItem` from the project; adjust helper `item()` if constructor differs.


test sample


```kotlin
/**
 * Test file for the Todo Application
 *
 * This file demonstrates unit testing in Kotlin using JUnit 5
 *
 * Key testing concepts covered:
 * - Test fixtures (setup/teardown)
 * - Assertions
 * - Test organization
 * - Edge cases
 * - Test naming conventions
 */
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.DisplayName
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test

/**
 * Main test class for TodoApp
 *
 * @DisplayName provides a human-readable name for the test class This appears in test reports and
 * IDE test runners
 */
@DisplayName("TodoApp Tests")
class TodoTest {

  // lateinit var means "I'll initialize this later, before using it"
  // Used here because we want a fresh TodoApp instance for each test
  private lateinit var app: TodoApp

  /**
   * @BeforeEach runs before each test method
   *
   * This ensures each test starts with a clean state This is important for test isolation - tests
   * shouldn't affect each other
   */
  @BeforeEach
  fun setUp() {
    app = TodoApp()
  }

  // ========================================
  // Tests for Data Class
  // ========================================

  /**
   * @Nested allows grouping related tests together This improves test organization and readability
   */
  @Nested
  @DisplayName("Todo Data Class Tests")
  inner class TodoDataClassTests {

    @Test
    @DisplayName("Todo should be created with correct properties")
    fun testTodoCreation() {
      // Arrange: Set up test data
      val id = 1
      val title = "Buy groceries"
      val completed = false

      // Act: Perform the action we're testing
      val todo = Todo(id, title, completed)

      // Assert: Verify the results
      // assertEquals(expected, actual, optionalMessage)
      assertEquals(id, todo.id, "Todo ID should match")
      assertEquals(title, todo.title, "Todo title should match")
      assertEquals(completed, todo.completed, "Todo completion status should match")
    }

    @Test
    @DisplayName("Todo should default to incomplete")
    fun testTodoDefaultCompletion() {
      // Test that the default parameter works correctly
      val todo = Todo(1, "Test task")

      // assertFalse checks that a condition is false
      assertFalse(todo.completed, "New todos should be incomplete by default")
    }

    @Test
    @DisplayName("Todo copy() should create modified instance")
    fun testTodoCopy() {
      // Test the data class copy() function
      val original = Todo(1, "Original task", false)

      // Create a copy with completed = true
      val modified = original.copy(completed = true)

      // Verify the copy has the new value
      assertTrue(modified.completed, "Copied todo should be marked as completed")

      // Verify the copy has the same other properties
      assertEquals(original.id, modified.id, "ID should remain the same")
      assertEquals(original.title, modified.title, "Title should remain the same")

      // Verify the original is unchanged
      assertFalse(original.completed, "Original todo should remain unchanged")
    }

    @Test
    @DisplayName("Todo equals() should work correctly")
    fun testTodoEquality() {
      // Data classes automatically implement equals()
      // Two instances with same property values are equal
      val todo1 = Todo(1, "Task", false)
      val todo2 = Todo(1, "Task", false)
      val todo3 = Todo(2, "Task", false)

      assertEquals(todo1, todo2, "Todos with same properties should be equal")
      assertNotEquals(todo1, todo3, "Todos with different IDs should not be equal")
    }
  }

  // ========================================
  // Tests for Adding Todos
  // ========================================

  @Nested
  @DisplayName("Add Todo Tests")
  inner class AddTodoTests {

    @Test
    @DisplayName("Adding a todo should increase list size")
    fun testAddTodoIncreasesSize() {
      // Initially empty
      assertEquals(0, app.getTodos().size, "Initial todo list should be empty")

      // Add one todo
      app.addTodoDirectly("First task")
      assertEquals(1, app.getTodos().size, "List should have 1 todo after adding one")

      // Add another
      app.addTodoDirectly("Second task")
      assertEquals(2, app.getTodos().size, "List should have 2 todos after adding two")
    }

    @Test
    @DisplayName("Added todo should have correct properties")
    fun testAddedTodoProperties() {
      val title = "Test Task"
      val todo = app.addTodoDirectly(title)

      // Verify the todo has the correct properties
      assertEquals(title, todo.title, "Todo should have the provided title")
      assertFalse(todo.completed, "New todo should be incomplete")
      assertTrue(todo.id > 0, "Todo should have a positive ID")
    }

    @Test
    @DisplayName("Each todo should have a unique ID")
    fun testUniqueTodoIds() {
      val todo1 = app.addTodoDirectly("First")
      val todo2 = app.addTodoDirectly("Second")
      val todo3 = app.addTodoDirectly("Third")

      // All IDs should be different
      assertNotEquals(todo1.id, todo2.id, "First and second todos should have different IDs")
      assertNotEquals(todo2.id, todo3.id, "Second and third todos should have different IDs")
      assertNotEquals(todo1.id, todo3.id, "First and third todos should have different IDs")

      // IDs should be sequential
      assertEquals(todo1.id + 1, todo2.id, "IDs should be sequential")
      assertEquals(todo2.id + 1, todo3.id, "IDs should be sequential")
    }

    @Test
    @DisplayName("Whitespace in title should be trimmed")
    fun testTitleTrimming() {
      val todo = app.addTodoDirectly("  Task with spaces  ")
      assertEquals("Task with spaces", todo.title, "Title should be trimmed")
    }
  }

  // ========================================
  // Tests for Listing Todos
  // ========================================

  @Nested
  @DisplayName("List Todos Tests")
  inner class ListTodosTests {

    @Test
    @DisplayName("getTodos() should return empty list initially")
    fun testInitiallyEmpty() {
      val todos = app.getTodos()

      // assertTrue checks that a condition is true
      assertTrue(todos.isEmpty(), "Initial todo list should be empty")
    }

    @Test
    @DisplayName("getTodos() should return all added todos")
    fun testGetAllTodos() {
      // Add multiple todos
      app.addTodoDirectly("Task 1")
      app.addTodoDirectly("Task 2")
      app.addTodoDirectly("Task 3")

      val todos = app.getTodos()

      assertEquals(3, todos.size, "Should return all 3 todos")
    }

    @Test
    @DisplayName("getTodos() should return a copy, not the original list")
    fun testGetTodosReturnsCopy() {
      app.addTodoDirectly("Task 1")

      // Get the list
      val todos = app.getTodos()
      val originalSize = todos.size

      // Try to modify the returned list (this should work without affecting app)
      val mutableTodos = todos.toMutableList()
      mutableTodos.add(Todo(999, "Fake task"))

      // The app's list should be unchanged
      assertEquals(
              originalSize,
              app.getTodos().size,
              "Modifying returned list should not affect app's internal list"
      )
    }
  }

  // ========================================
  // Tests for Completing Todos
  // ========================================

  @Nested
  @DisplayName("Complete Todo Tests")
  inner class CompleteTodoTests {

    @Test
    @DisplayName("Completing a todo should set completed to true")
    fun testCompleteTodo() {
      // Add a todo
      val todo = app.addTodoDirectly("Task to complete")
      assertFalse(todo.completed, "Todo should start incomplete")

      // Complete it
      val success = app.completeTodoById(todo.id)

      // Verify it succeeded
      assertTrue(success, "Completing todo should return true")

      // Verify it's now completed
      val updatedTodo = app.getTodos().first { it.id == todo.id }
      assertTrue(updatedTodo.completed, "Todo should be marked as completed")
    }

    @Test
    @DisplayName("Completing non-existent todo should return false")
    fun testCompleteNonExistentTodo() {
      val success = app.completeTodoById(999)
      assertFalse(success, "Completing non-existent todo should return false")
    }

    @Test
    @DisplayName("Completing already completed todo should return false")
    fun testCompleteAlreadyCompletedTodo() {
      // Add and complete a todo
      val todo = app.addTodoDirectly("Task")
      app.completeTodoById(todo.id)

      // Try to complete it again
      val success = app.completeTodoById(todo.id)
      assertFalse(success, "Completing already completed todo should return false")
    }

    @Test
    @DisplayName("Completing one todo should not affect others")
    fun testCompleteOnlyAffectsTargetTodo() {
      val todo1 = app.addTodoDirectly("Task 1")
      val todo2 = app.addTodoDirectly("Task 2")
      val todo3 = app.addTodoDirectly("Task 3")

      // Complete only the second one
      app.completeTodoById(todo2.id)

      val todos = app.getTodos()
      assertFalse(
              todos.first { it.id == todo1.id }.completed,
              "First todo should remain incomplete"
      )
      assertTrue(todos.first { it.id == todo2.id }.completed, "Second todo should be completed")
      assertFalse(
              todos.first { it.id == todo3.id }.completed,
              "Third todo should remain incomplete"
      )
    }
  }

  // ========================================
  // Tests for Deleting Todos
  // ========================================

  @Nested
  @DisplayName("Delete Todo Tests")
  inner class DeleteTodoTests {

    @Test
    @DisplayName("Deleting a todo should remove it from list")
    fun testDeleteTodo() {
      val todo = app.addTodoDirectly("Task to delete")
      assertEquals(1, app.getTodos().size, "Should have 1 todo")

      val success = app.deleteTodoById(todo.id)

      assertTrue(success, "Deleting existing todo should return true")
      assertEquals(0, app.getTodos().size, "Todo list should be empty after deletion")
    }

    @Test
    @DisplayName("Deleting non-existent todo should return false")
    fun testDeleteNonExistentTodo() {
      val success = app.deleteTodoById(999)
      assertFalse(success, "Deleting non-existent todo should return false")
    }

    @Test
    @DisplayName("Deleting one todo should not affect others")
    fun testDeleteOnlyAffectsTargetTodo() {
      val todo1 = app.addTodoDirectly("Task 1")
      val todo2 = app.addTodoDirectly("Task 2")
      val todo3 = app.addTodoDirectly("Task 3")

      // Delete the second one
      app.deleteTodoById(todo2.id)

      val todos = app.getTodos()
      assertEquals(2, todos.size, "Should have 2 todos remaining")

      // Verify the right one was deleted
      assertNotNull(todos.firstOrNull { it.id == todo1.id }, "First todo should still exist")
      assertNull(todos.firstOrNull { it.id == todo2.id }, "Second todo should be deleted")
      assertNotNull(todos.firstOrNull { it.id == todo3.id }, "Third todo should still exist")
    }

    @Test
    @DisplayName("Can delete all todos one by one")
    fun testDeleteAllTodos() {
      val todo1 = app.addTodoDirectly("Task 1")
      val todo2 = app.addTodoDirectly("Task 2")
      val todo3 = app.addTodoDirectly("Task 3")

      app.deleteTodoById(todo1.id)
      assertEquals(2, app.getTodos().size)

      app.deleteTodoById(todo2.id)
      assertEquals(1, app.getTodos().size)

      app.deleteTodoById(todo3.id)
      assertEquals(0, app.getTodos().size)
      assertTrue(app.getTodos().isEmpty(), "All todos should be deleted")
    }
  }

  // ========================================
  // Tests for Clear Functionality
  // ========================================

  @Nested
  @DisplayName("Clear Todos Tests")
  inner class ClearTodosTests {

    @Test
    @DisplayName("Clear should remove all todos")
    fun testClearAllTodos() {
      // Add several todos
      app.addTodoDirectly("Task 1")
      app.addTodoDirectly("Task 2")
      app.addTodoDirectly("Task 3")

      assertEquals(3, app.getTodos().size, "Should have 3 todos")

      // Clear all
      app.clearTodos()

      assertEquals(0, app.getTodos().size, "Should have no todos after clear")
      assertTrue(app.getTodos().isEmpty(), "Todo list should be empty")
    }

    @Test
    @DisplayName("Clear on empty list should work without errors")
    fun testClearEmptyList() {
      // This should not throw an exception
      // assertDoesNotThrow is used when we want to verify no exception occurs
      assertDoesNotThrow { app.clearTodos() }

      assertTrue(app.getTodos().isEmpty(), "List should still be empty")
    }
  }

  // ========================================
  // Integration Tests
  // ========================================

  @Nested
  @DisplayName("Integration Tests")
  inner class IntegrationTests {

    @Test
    @DisplayName("Complete workflow: add, complete, and delete")
    fun testCompleteWorkflow() {
      // Add todos
      val todo1 = app.addTodoDirectly("Buy milk")
      val todo2 = app.addTodoDirectly("Write code")
      val todo3 = app.addTodoDirectly("Exercise")

      // Verify all added
      assertEquals(3, app.getTodos().size)

      // Complete one
      app.completeTodoById(todo2.id)
      val todos = app.getTodos()
      assertTrue(todos.first { it.id == todo2.id }.completed)

      // Delete one
      app.deleteTodoById(todo1.id)
      assertEquals(2, app.getTodos().size)

      // Verify final state
      val finalTodos = app.getTodos()
      assertEquals(2, finalTodos.size)
      assertNull(finalTodos.firstOrNull { it.id == todo1.id }, "Deleted todo should not exist")
      assertTrue(
              finalTodos.first { it.id == todo2.id }.completed,
              "Completed todo should still be completed"
      )
      assertFalse(
              finalTodos.first { it.id == todo3.id }.completed,
              "Untouched todo should remain incomplete"
      )
    }

    @Test
    @DisplayName("IDs should remain unique even after deletions")
    fun testIdsPersistAfterDeletion() {
      // Add and delete a todo
      val todo1 = app.addTodoDirectly("First")
      app.deleteTodoById(todo1.id)

      // Add another - it should have a new, higher ID
      val todo2 = app.addTodoDirectly("Second")

      assertTrue(todo2.id > todo1.id, "New todo should have higher ID than deleted one")
    }
  }

  // ========================================
  // Edge Cases and Error Handling
  // ========================================

  @Nested
  @DisplayName("Edge Cases")
  inner class EdgeCaseTests {

    @Test
    @DisplayName("Todo with empty title (after trimming)")
    fun testEmptyTitleAfterTrimming() {
      // The app's addTodoDirectly doesn't validate, but this tests the data model
      val todo = app.addTodoDirectly("   ")
      assertEquals("", todo.title, "Title should be empty string after trimming spaces")
    }

    @Test
    @DisplayName("Todo with very long title")
    fun testLongTitle() {
      val longTitle = "A".repeat(1000)
      val todo = app.addTodoDirectly(longTitle)
      assertEquals(longTitle, todo.title, "Should handle long titles")
    }

    @Test
    @DisplayName("Todo with special characters")
    fun testSpecialCharacters() {
      val specialTitle = "Buy groceries ðŸ›’ @ store (50% off!) #sale"
      val todo = app.addTodoDirectly(specialTitle)
      assertEquals(specialTitle, todo.title, "Should handle special characters and emojis")
    }

    @Test
    @DisplayName("Multiple operations on same todo")
    fun testMultipleOperationsOnSameTodo() {
      val todo = app.addTodoDirectly("Task")

      // Complete it
      assertTrue(app.completeTodoById(todo.id))

      // Try to complete again (should fail)
      assertFalse(app.completeTodoById(todo.id))

      // Delete it
      assertTrue(app.deleteTodoById(todo.id))

      // Try to delete again (should fail - already gone)
      assertFalse(app.deleteTodoById(todo.id))

      // Try to complete after deletion (should fail)
      assertFalse(app.completeTodoById(todo.id))
    }
  }
}

```
